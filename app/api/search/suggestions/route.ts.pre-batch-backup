// TODO: MIGRATE TO PRISMA - этот файл использует Supabase queries
// Они работают, но требуют миграции на Prisma для consistency

import { generateJSON } from '@/lib/ai/gemini'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'
import { NextResponse } from 'next/server'

/**
 * POST /api/search/suggestions - Генерация AI-подсказок для поиска
 * 
 * Использует Gemini для генерации умных подсказок на основе:
 * - Частичного ввода пользователя
 * - Популярных запросов
 * - Доступных услуг в базе
 */
export async function POST(request: Request) {
  try {
    const body = await request.json()
    const { query, limit = 5 } = body

    if (!query || query.trim().length < 2) {
      return NextResponse.json({ suggestions: [] })
    }

    // Supabase client removed

    // 1. Получаем категории и популярные теги из базы
    const { data: categories } = await supabase
      .from('service_categories')
      .select('name')
      .limit(10)

    const { data: popularServices } = await supabase
      .from('services')
      .select('title, tags')
      .eq('active', true)
      .order('created_at', { ascending: false })
      .limit(20)

    // Извлекаем уникальные теги
    const allTags = popularServices
      ?.flatMap(s => s.tags || [])
      .filter((tag, index, self) => self.indexOf(tag) === index) || []

    // 2. Генерируем подсказки с помощью Gemini
    const prompt = `Ты - помощник для поиска детских праздников и развлечений.

Пользователь начал вводить запрос: "${query}"

Доступные категории услуг: ${categories?.map(c => c.name).join(', ')}
Популярные теги: ${allTags.slice(0, 20).join(', ')}

Сгенерируй ${limit} КРАТКИХ и РЕЛЕВАНТНЫХ подсказок для автодополнения поиска.
Подсказки должны:
- Быть конкретными и полезными
- Учитывать контекст детских праздников
- Включать возраст, если уместно
- Быть разными по формулировке
- Помогать найти услуги

Примеры хороших подсказок:
- "аниматор человек-паук для мальчика 5 лет"
- "химическое шоу на день рождения"
- "квест для подростков 12-14 лет"

Верни JSON массив строк.`

    const result = await generateJSON(prompt, {
      type: 'object',
      properties: {
        suggestions: {
          type: 'array',
          items: { type: 'string' },
          description: 'Массив подсказок для автодополнения',
        },
      },
      required: ['suggestions'],
    })

    return NextResponse.json({
      suggestions: result.suggestions.slice(0, limit),
    })
  } catch (error: any) {
    console.error('Suggestions generation error:', error)
    
    // Fallback на базовые подсказки
    const fallbackSuggestions = [
      'аниматор на день рождения',
      'детский праздник',
      'химическое шоу',
      'квест для детей',
      'организация праздника',
    ]
    
    return NextResponse.json({
      suggestions: fallbackSuggestions,
    })
  }
}

/**
 * GET /api/search/suggestions - Получить популярные запросы
 */
export async function GET() {
  try {
    // Supabase client removed

    // В будущем можно добавить таблицу search_queries для трекинга
    // Пока возвращаем базовые популярные запросы
    const trendingSearches = [
      'аниматор на день рождения',
      'химическое шоу',
      'организация детского праздника',
      'квест для детей',
      'детская фотосессия',
      'шоу мыльных пузырей',
      'аквагрим',
      'праздник для малышей',
    ]

    // Получаем самые популярные теги из услуг
    const { data: services } = await supabase
      .from('services')
      .select('tags, title')
      .eq('active', true)
      .order('created_at', { ascending: false })
      .limit(50)

    // Подсчитываем частоту тегов
    const tagFrequency: Record<string, number> = {}
    services?.forEach(service => {
      service.tags?.forEach((tag: string) => {
        tagFrequency[tag] = (tagFrequency[tag] || 0) + 1
      })
    })

    // Топ-5 тегов
    const topTags = Object.entries(tagFrequency)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5)
      .map(([tag]) => tag)

    return NextResponse.json({
      trending: trendingSearches,
      popularTags: topTags,
    })
  } catch (error: any) {
    console.error('Trending searches error:', error)
    return NextResponse.json(
      { error: 'Failed to fetch trending searches' },
      { status: 500 }
    )
  }
}


