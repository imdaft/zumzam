import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

/**
 * API endpoint для транскрипции голосовых сообщений
 * Поддерживает:
 * - Whisper (локальный, через transformers.js)
 * - Gemini 2.0 Flash (облачный)
 */
export async function POST(request: NextRequest) {
  try {
    console.log('[STT API] Request received')
    
    const formData = await request.formData()
    const audioFile = formData.get('audio') as File

    if (!audioFile) {
      console.error('[STT API] No audio file provided')
      return NextResponse.json(
        { error: 'Аудио файл обязателен' },
        { status: 400 }
      )
    }

    console.log('[STT API] Audio file:', {
      name: audioFile.name,
      size: audioFile.size,
      type: audioFile.type
    })

    // Получаем активную настройку STT
    const supabase = await createClient()
    const { data: activeSetting, error: settingError } = await supabase
      .from('stt_settings')
      .select('*')
      .eq('is_active', true)
      .single()

    if (settingError || !activeSetting) {
      console.error('[STT API] No active STT setting found:', settingError)
      // Fallback to Whisper
      return transcribeWithWhisper(audioFile)
    }

    console.log(`[STT API] Using provider: ${activeSetting.provider} (${activeSetting.name})`)

    // Выбираем провайдер
    if (activeSetting.provider === 'gemini') {
      return transcribeWithGemini(audioFile, activeSetting.settings)
    } else {
      return transcribeWithWhisper(audioFile, activeSetting.settings)
    }

  } catch (error: any) {
    console.error('[STT API] Unexpected error:', error)
    console.error('[STT API] Stack:', error.stack)
    return NextResponse.json(
      { error: 'Неожиданная ошибка', details: error.message, stack: error.stack },
      { status: 500 }
    )
  }
}

/**
 * Транскрипция через Gemini 2.0 Flash
 */
async function transcribeWithGemini(audioFile: File, settings: any = {}) {
  try {
    console.log('[Gemini STT] Starting transcription...')

    // Читаем аудио как base64
    const arrayBuffer = await audioFile.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)
    const base64Audio = buffer.toString('base64')

    // Gemini API
    const { GoogleGenerativeAI } = await import('@google/generative-ai')
    const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY!)
    
    const model = genAI.getGenerativeModel({ 
      model: settings.model || 'gemini-2.0-flash-exp'
    })

    const result = await model.generateContent([
      {
        inlineData: {
          data: base64Audio,
          mimeType: settings.mimeType || 'audio/webm'
        }
      },
      {
        text: 'Пожалуйста, транскрибируй эту аудиозапись на русском языке. Верни только текст без пояснений.'
      }
    ])

    const response = await result.response
    const text = response.text().trim()
    
    console.log('[Gemini STT] Transcription successful:', text)

    return NextResponse.json({
      text,
      language: 'ru',
      provider: 'gemini'
    })
  } catch (error: any) {
    console.error('[Gemini STT] Error:', error)
    return NextResponse.json(
      { error: 'Ошибка Gemini STT', details: error.message },
      { status: 500 }
    )
  }
}

/**
 * Транскрипция через Whisper (локальный)
 */
async function transcribeWithWhisper(audioFile: File, settings: any = {}) {
  try {
    console.log('[Whisper STT] Starting transcription...')
    
    // Динамический импорт transformers
    console.log('[Whisper STT] Loading transformers...')
    let pipeline: any
    try {
      const { pipeline: pipelineFn } = await import('@xenova/transformers')
      pipeline = pipelineFn
      console.log('[Whisper STT] Transformers loaded!')
    } catch (importError: any) {
      console.error('[Whisper STT] Import error:', importError)
      return NextResponse.json(
        { error: 'Не удалось загрузить модуль транскрипции', details: importError.message },
        { status: 500 }
      )
    }

    // Инициализация модели
    console.log('[Whisper STT] Loading Whisper model...')
    let transcriber: any
    try {
      transcriber = await pipeline(
        'automatic-speech-recognition',
        settings.model || 'Xenova/whisper-small'
      )
      console.log('[Whisper STT] Model loaded successfully!')
    } catch (modelError: any) {
      console.error('[Whisper STT] Model loading error:', modelError)
      return NextResponse.json(
        { error: 'Ошибка загрузки модели Whisper', details: modelError.message },
        { status: 500 }
      )
    }

    // Читаем аудио
    console.log('[Whisper STT] Reading audio buffer...')
    const arrayBuffer = await audioFile.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)
    console.log('[Whisper STT] Buffer ready, size:', buffer.length)

    // Подготовка временных файлов
    const fs = await import('fs')
    const path = await import('path')
    const os = await import('os')
    const tempDir = os.tmpdir()
    const tempFile = path.join(tempDir, `whisper-${Date.now()}.webm`)
    const tempWav = tempFile.replace('.webm', '.wav')

    // Сохраняем WebM во временный файл
    console.log('[Whisper STT] Saving to temp file:', tempFile)
    fs.writeFileSync(tempFile, buffer)

    // Декодируем в WAV (16kHz mono) через ffmpeg
    console.log('[Whisper STT] Converting to WAV via ffmpeg...')
    const { default: ffmpegStatic } = await import('ffmpeg-static')
    const ffmpegPath = ffmpegStatic || 'ffmpeg'
    const { execFile } = await import('child_process')

    await new Promise<void>((resolve, reject) => {
      execFile(
        ffmpegPath,
        ['-y', '-i', tempFile, '-ac', '1', '-ar', '16000', '-f', 'wav', tempWav],
        (err) => {
          if (err) {
            console.error('[Whisper STT] ffmpeg error:', err)
            return reject(err)
          }
          resolve()
        }
      )
    })
    console.log('[Whisper STT] WAV ready:', tempWav)

    // Парсим WAV и получаем Float32Array
    const wavDecoder = await import('wav-decoder')
    const wavBuffer = fs.readFileSync(tempWav)
    const decoded = await wavDecoder.default.decode(wavBuffer)
    const sampleRate = decoded.sampleRate || 16000
    const channelData = decoded.channelData?.[0]

    if (!channelData) {
      console.error('[Whisper STT] No channel data after decode')
      fs.unlinkSync(tempFile)
      fs.unlinkSync(tempWav)
      return NextResponse.json(
        { error: 'Не удалось декодировать аудио' },
        { status: 400 }
      )
    }

    const audioFloat32 =
      channelData instanceof Float32Array ? channelData : Float32Array.from(channelData)
    console.log(
      '[Whisper STT] Audio ready, sampleRate:',
      sampleRate,
      'length:',
      audioFloat32.length
    )

    // Транскрипция
    console.log('[Whisper STT] Starting transcription...')
    try {
      // Передаем готовый PCM (Float32Array) напрямую
      const result = await transcriber(audioFloat32, {
        language: settings.language || 'ru',
        task: 'transcribe',
        return_timestamps: false,
        sampling_rate: sampleRate,
      })

      const text = result.text.trim()
      console.log('[Whisper STT] Transcription successful:', text)
      
      // Удаляем временный файл
      try {
        fs.unlinkSync(tempFile)
        fs.unlinkSync(tempWav)
        console.log('[Whisper STT] Temp file deleted')
      } catch (e) {
        console.warn('[Whisper STT] Could not delete temp file:', e)
      }

      return NextResponse.json({
        text,
        language: settings.language || 'ru',
        duration: audioFloat32.length / sampleRate,
        provider: 'whisper'
      })
    } catch (transcribeError: any) {
      console.error('[Whisper STT] Transcription error:', transcribeError)
      
      // Удаляем временный файл при ошибке
      try {
        fs.unlinkSync(tempFile)
        fs.unlinkSync(tempWav)
      } catch (e) {
        // ignore
      }
      
      return NextResponse.json(
        { error: 'Ошибка при распознавании речи', details: transcribeError.message },
        { status: 500 }
      )
    }
  } catch (error: any) {
    console.error('[Whisper STT] Unexpected error:', error)
    return NextResponse.json(
      { error: 'Ошибка Whisper STT', details: error.message },
      { status: 500 }
    )
  }
}

// Node.js runtime для работы с transformers
export const runtime = 'nodejs'
export const maxDuration = 60
