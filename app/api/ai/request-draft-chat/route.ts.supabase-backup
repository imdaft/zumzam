import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

const DEFAULT_CITY = '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥'
const CURRENT_YEAR = new Date().getFullYear()

type DraftType = {
  category?: string
  title?: string
  description?: string
  eventDate?: string
  eventTime?: string
  city?: string
  district?: string
  address?: string
  venueType?: string
  budget?: number
  budgetNegotiable?: boolean
  clientType?: string
  childrenCount?: number
  childrenAgeRange?: { from?: number; to?: number }
  birthdayChild?: { name?: string; age?: number }
  contactName?: string
  contactPhone?: string
  contactMethod?: string
  preferredContactTime?: string
  details?: Record<string, unknown>
}

function normalizePhone(phone?: string): string | undefined {
  if (!phone) return undefined
  const clean = phone.replace(/[^\d+]/g, '')
  const m = clean.match(/(\+7|7|8)?\d{10}/)
  if (!m) return undefined
  let digits = m[0]
  if (digits.startsWith('8')) digits = '+7' + digits.slice(1)
  if (digits.startsWith('7')) digits = '+7' + digits.slice(1)
  if (!digits.startsWith('+7')) digits = '+7' + digits
  return digits
}

function safeNumber(value: number | undefined): number | undefined {
  return Number.isFinite(value) ? value : undefined
}

function parseBudget(text: string): number | undefined {
  const cleanedText = text.replace(/\b\d{1,2}[:.]\d{2}\b/g, ' ')
  const matches = cleanedText.match(/(\d[\d\s.,]{2,})/g)
  if (!matches) return undefined
  const numbers = matches
    .map((m) => m.replace(/\s/g, '').replace(/[,\.]/g, ''))
    .map((m) => parseInt(m, 10))
    .filter((n) => Number.isFinite(n))
    .filter((n) => n >= 500)
  if (numbers.length === 0) return undefined
  return Math.max(...numbers)
}

function parseTime(text: string): string | undefined {
  const full = text.match(/\b(\d{1,2})[:.](\d{2})\b/)
  if (full) {
    const hh = full[1].padStart(2, '0')
    const mm = full[2]
    return `${hh}:${mm}`
  }
  const withMeridiem = text.match(/\b(?:–≤\s*)?(\d{1,2})\s*(—É—Ç—Ä–∞|–≤–µ—á–µ—Ä–∞|–¥–Ω—è|–Ω–æ—á–∏)\b/i)
  if (withMeridiem) {
    let hhNum = parseInt(withMeridiem[1], 10)
    const meridiem = withMeridiem[2].toLowerCase()
    if (meridiem.includes('–≤–µ—á–µ—Ä') || meridiem.includes('–Ω–æ—á–∏')) {
      if (hhNum < 12) hhNum += 12
    }
    const hh = hhNum.toString().padStart(2, '0')
    return `${hh}:00`
  }
  const hourOnly = text.match(/\b–≤\s*(\d{1,2})\b/i)
  if (hourOnly) {
    const hh = hourOnly[1].padStart(2, '0')
    return `${hh}:00`
  }
  return undefined
}

function parseDate(text: string): string | undefined {
  const monthMap: Record<string, number> = {
    —è–Ω–≤: 0, —Ñ–µ–≤: 1, –º–∞—Ä: 2, –∞–ø—Ä: 3, –º–∞—è: 4, –º–∞–π: 4, –∏—é–Ω: 5, –∏—é–ª: 6, –∞–≤–≥: 7, —Å–µ–Ω: 8, –æ–∫—Ç: 9, –æ–∫—Ç—è: 9, –Ω–æ—è: 10, –¥–µ–∫: 11,
  }
  const dot = text.match(/\b(\d{1,2})[./](\d{1,2})(?:[./](\d{2,4}))?\b/)
  if (dot) {
    const day = parseInt(dot[1], 10)
    const mon = parseInt(dot[2], 10) - 1
    const year = dot[3] ? parseInt(dot[3], 10) + (dot[3].length === 2 ? 2000 : 0) : CURRENT_YEAR
    if (day >= 1 && day <= 31 && mon >= 0 && mon <= 11) {
      return `${year}-${(mon + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`
    }
  }
  const words = text.match(/\b(\d{1,2})\s?(—è–Ω–≤|—Ñ–µ–≤|–º–∞—Ä|–∞–ø—Ä|–º–∞[–π—è]|–∏—é–Ω|–∏—é–ª|–∞–≤–≥|—Å–µ–Ω|–æ–∫—Ç|–Ω–æ—è|–¥–µ–∫)\w*/i)
  if (words) {
    const day = parseInt(words[1], 10)
    const monKey = words[2].slice(0, 3).toLowerCase()
    const mon = monthMap[monKey]
    if (mon !== undefined) {
      let year = CURRENT_YEAR
      const today = new Date()
      const candidate = new Date(year, mon, day)
      if (candidate.getTime() < today.getTime()) {
        year += 1
      }
      return `${year}-${(mon + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`
    }
  }
  return undefined
}

function parseAddress(text: string): { city?: string; address?: string } {
  let city: string | undefined
  if (/–º–æ—Å–∫–≤/i.test(text)) city = '–ú–æ—Å–∫–≤–∞'
  if (/—Å–ø–±|—Å–∞–Ω–∫—Ç[- ]?–ø–µ—Ç–µ—Ä–±—É—Ä–≥|–ø–∏—Ç–µ—Ä/i.test(text)) city = '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥'
  const addrMatch = text.match(/(?:–≤|–Ω–∞)\s+([A-Za-z–ê-–Ø–∞-—è0-9"¬´¬ª\s\-]+?)(?:[,\.]|$)/i)
  const address = addrMatch ? addrMatch[1].trim() : undefined
  return { city, address }
}

function parseChildrenCount(text: string): number | undefined {
  const matches: number[] = []
  const patterns = [
    /(?:–¥–µ—Ç[–µ–∏]|–¥–µ—Ç—è–º|–¥–µ—Ç–∫–∞–º|—Ä–µ–±—è—Ç|—á–µ–ª–æ–≤–µ–∫|—á–µ–ª)\s*(?:–±—É–¥–µ—Ç|–±—É–¥—É—Ç|–æ–∫–æ–ª–æ|–ø—Ä–∏–º–µ—Ä–Ω–æ|~)?\s*(\d{1,3})/gi,
    /(\d{1,3})\s*(?:–¥–µ—Ç[–µ–∏]|–¥–µ—Ç—è–º|–¥–µ—Ç–∫–∞–º|—á–µ–ª–æ–≤–µ–∫|—á–µ–ª|—Ä–µ–±—è—Ç)/gi,
    /–¥–µ—Ç–µ–π\s*[\.,]?\s*(\d{1,3})/gi,
  ]

  for (const re of patterns) {
    let m: RegExpExecArray | null
    while ((m = re.exec(text)) !== null) {
      const num = parseInt(m[1], 10)
      if (Number.isFinite(num)) matches.push(num)
    }
  }

  if (matches.length === 0) return undefined
  return Math.max(...matches)
}

function parseChildrenAge(text: string): { from?: number; to?: number; single?: number } | undefined {
  const m2 = text.match(/(\d{1,2})\s*[-‚Äì]\s*(\d{1,2})\s*(?:–ª–µ—Ç|–≥–æ–¥)/i)
  if (m2) {
    const from = parseInt(m2[1], 10)
    const to = parseInt(m2[2], 10)
    if (Number.isFinite(from) && Number.isFinite(to)) {
      return { from, to }
    }
  }
  const m = text.match(/(\d{1,2})\s*(?:–ª–µ—Ç|–≥–æ–¥[–∞—É]?)/i)
  if (m) {
    const age = parseInt(m[1], 10)
    if (Number.isFinite(age)) {
      return { from: age, to: age, single: age }
    }
  }
  return undefined
}

function detectCategory(text: string): string | undefined {
  if (/—Ñ–æ–∫—É—Å–Ω–∏–∫|–∏–ª–ª—é–∑/i.test(text)) return 'show'
  if (/–∞–Ω–∏–º–∞—Ç–æ—Ä|–≥–µ—Ä–æ|–ø–µ—Ä—Å–æ–Ω–∞–∂|—Ä–æ—Å—Ç–æ–≤/i.test(text)) return 'animator'
  if (/–≤–µ–¥—É—â/i.test(text)) return 'host'
  if (/–∫–≤–µ—Å—Ç/i.test(text)) return 'quest'
  if (/–º–∞—Å—Ç–µ—Ä[- ]?–∫–ª–∞—Å—Å|–ú–ö/i.test(text)) return 'masterclass'
  if (/—Ñ–æ—Ç–æ|–≤–∏–¥–µ–æ|—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ|–≤–∏–¥–µ–æ–≥—Ä–∞—Ñ/i.test(text)) return 'photo_video'
  if (/–¥–µ–¥\s?–º–æ—Ä–æ–∑|—Å–Ω–µ–≥—É—Ä–æ—á/i.test(text)) return 'santa'
  return undefined
}

function parseVenueType(text: string): string | undefined {
  if (/—Ä–µ—Å—Ç–æ—Ä–∞–Ω|–∫–∞—Ñ–µ|–±–∞–Ω–∫–µ—Ç/i.test(text)) return 'restaurant'
  if (/–∫–≤–∞—Ä—Ç–∏—Ä–∞|–¥–æ–º–∞|–¥–æ–º|–∫–æ—Ç—Ç–µ–¥–∂|–∑–∞–≥–æ—Ä–æ–¥|–Ω–∞ –¥–æ–º—É/i.test(text)) return 'home'
  if (/–ø–∞—Ä–∫|—É–ª–∏—Ü|open\s?air|–Ω–∞ —É–ª–∏—Ü–µ/i.test(text)) return 'outdoor'
  if (/—à–∫–æ–ª|—Å–∞–¥–∏–∫|–¥–µ—Ç—Å–∫–∏–π —Å–∞–¥/i.test(text)) return 'school'
  if (/–æ—Ñ–∏—Å/i.test(text)) return 'office'
  if (/–ª–æ—Ñ—Ç|—Å—Ç—É–¥–∏—è|–ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤/i.test(text)) return 'other'
  if (/–∫–ª—É–±/i.test(text)) return 'club'
  return undefined
}

function detectShowType(text: string): string | undefined {
  if (/—Ñ–æ–∫—É—Å/i.test(text)) return 'magic'
  return undefined
}

function buildDescription(text: string): string | undefined {
  const cleaned = text
    .replace(/—Å–æ–∑–¥–∞–π\s+–æ–±—ä—è–≤–ª–µ–Ω–∏–µ[:,]?\s*/i, '')
    .trim()
  if (!cleaned) return undefined
  return cleaned.slice(0, 400)
}

function parsePhone(text: string): string | undefined {
  return normalizePhone(text)
}

function parseDraftQuick(primaryText: string, contextText?: string): DraftType {
  const base = primaryText
  const fallback = contextText && contextText !== primaryText ? contextText : ''
  const combined = `${base}\n${fallback}`.trim()

  const pick = <T>(primary: T | undefined, fallbackValue: T | undefined) =>
    primary !== undefined && primary !== null ? primary : fallbackValue

  const category = pick(detectCategory(base), detectCategory(fallback))
  const budget = pick(parseBudget(base), parseBudget(fallback)) ?? parseBudget(combined)
  const budgetNegotiable =
    pick(/–¥–æ–≥–æ–≤–æ—Ä–Ω/i.test(base) ? true : undefined, /–¥–æ–≥–æ–≤–æ—Ä–Ω/i.test(fallback) ? true : undefined) ??
    (/–¥–æ–≥–æ–≤–æ—Ä–Ω/i.test(combined) ? true : undefined)
  const eventTime = pick(parseTime(base), parseTime(fallback)) ?? parseTime(combined)
  const eventDate = pick(parseDate(base), parseDate(fallback)) ?? parseDate(combined)

  const primaryAddr = parseAddress(base)
  const fallbackAddr = parseAddress(fallback)
  const city = pick(primaryAddr.city, fallbackAddr.city)
  const address = pick(primaryAddr.address, fallbackAddr.address)

  const childrenCount = pick(parseChildrenCount(base), parseChildrenCount(fallback))
  const ageData = pick(parseChildrenAge(base), parseChildrenAge(fallback))
  const venueType = pick(parseVenueType(base), parseVenueType(fallback))
  const showType = pick(detectShowType(base), detectShowType(fallback))
  const description = pick(buildDescription(base), buildDescription(fallback))
  const contactPhone = parsePhone(primaryText)

  return {
    category,
    budget,
    budgetNegotiable,
    eventDate,
    eventTime,
    city: city || (address ? DEFAULT_CITY : undefined),
    address,
    venueType,
    clientType: 'parent',
    childrenCount,
    childrenAgeRange: ageData
      ? { from: ageData.from ?? ageData.single, to: ageData.to ?? ageData.single }
      : undefined,
    birthdayChild: ageData?.single ? { age: ageData.single } : undefined,
    details: showType ? { showType } : undefined,
    title: undefined,
    description,
    contactMethod: 'chat',
    preferredContactTime: 'any',
    contactPhone,
  }
}

function normalizeDraft(draft: DraftType): DraftType {
  return {
    category: draft.category || 'show',
    title: draft.title || '–ó–∞—è–≤–∫–∞ –Ω–∞ –ø—Ä–∞–∑–¥–Ω–∏–∫',
    description: draft.description,
    eventDate: draft.eventDate,
    eventTime: draft.eventTime,
    city: draft.city || DEFAULT_CITY,
    district: draft.district,
    address: draft.address,
    venueType: draft.venueType || 'home',
    clientType: draft.clientType || 'parent',
    contactMethod: draft.contactMethod || 'chat',
    preferredContactTime: draft.preferredContactTime || 'any',
    budget: safeNumber(draft.budget),
    budgetNegotiable: draft.budgetNegotiable ?? false,
    childrenCount: safeNumber(draft.childrenCount),
    childrenAgeRange: draft.childrenAgeRange,
    birthdayChild: draft.birthdayChild,
    contactName: draft.contactName,
    contactPhone: draft.contactPhone,
    details: draft.details || {},
  }
}

function missingFields(draft: DraftType) {
  const missing: string[] = []
  if (!draft.eventDate) missing.push('–¥–∞—Ç—É')
  if (!draft.eventTime) missing.push('–≤—Ä–µ–º—è')
  if (!draft.address && !draft.city) missing.push('–∞–¥—Ä–µ—Å/–≥–æ—Ä–æ–¥')
  if (!draft.category) missing.push('–∫–∞—Ç–µ–≥–æ—Ä–∏—é')
  if (!draft.budget && !draft.budgetNegotiable) missing.push('–±—é–¥–∂–µ—Ç')
  if (!draft.venueType) missing.push('—Ç–∏–ø –ø–ª–æ—â–∞–¥–∫–∏')
  if (!draft.clientType) missing.push('–∫—Ç–æ –≤—ã (—Ä–æ–¥–∏—Ç–µ–ª—å/–æ—Ä–≥–∞–Ω–∏–∑–∞—Ç–æ—Ä/–ø–ª–æ—â–∞–¥–∫–∞)')
  return missing
}

function optionalMissing(draft: DraftType) {
  const missing: string[] = []
  if (!draft.childrenCount && !draft.childrenAgeRange) missing.push('–≤–æ–∑—Ä–∞—Å—Ç/–∫–æ–ª-–≤–æ –¥–µ—Ç–µ–π')
  if (!draft.description) missing.push('–∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã')
  if (!draft.contactPhone) missing.push('—Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —Å–≤—è–∑–∏')
  return missing
}

function makeSummary(draft: DraftType) {
  const parts = [
    draft.eventDate ? `üìÖ ${draft.eventDate}` : null,
    draft.eventTime ? `‚è∞ ${draft.eventTime}` : null,
    draft.city ? `üìç ${draft.city}${draft.address ? ', ' + draft.address : ''}` : draft.address ? `üìç ${draft.address}` : null,
    draft.budget ? `üí∞ ${draft.budget.toLocaleString('ru-RU')} ‚ÇΩ` : draft.budgetNegotiable ? 'üí∞ –î–æ–≥–æ–≤–æ—Ä–Ω–∞—è' : null,
    draft.category ? `üß© ${draft.category}` : null,
  ].filter(Boolean)
  return parts.join(' ‚Ä¢ ')
}

function encodePrefill(draft: DraftType) {
  try {
    return Buffer.from(JSON.stringify(draft), 'utf-8').toString('base64url')
  } catch {
    return null
  }
}

export async function POST(request: NextRequest) {
  try {
    const { message, conversationHistory = [] } = await request.json()

    if (!message || typeof message !== 'string') {
      return NextResponse.json({ error: '–°–æ–æ–±—â–µ–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' }, { status: 400 })
    }

    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()
    let userPhone = normalizePhone(
      user?.phone ||
      user?.user_metadata?.phone ||
      user?.user_metadata?.phone_number ||
      user?.user_metadata?.phoneNumber
    )

    if (user && !userPhone) {
      const { data: profilePhone } = await supabase
        .from('profiles')
        .select('phone')
        .eq('user_id', user.id)
        .limit(1)
        .maybeSingle()
      if (profilePhone?.phone) {
        userPhone = normalizePhone(profilePhone.phone)
      }
    }

    const userContext = [
      ...(conversationHistory || [])
        .filter((m: any) => m.role === 'user')
        .slice(-5)
        .map((m: any) => m.content || ''),
      message,
    ].filter(Boolean).join('. ')

    const draft = normalizeDraft(parseDraftQuick(message, userContext))

    if (!draft.contactPhone && userPhone) {
      draft.contactPhone = userPhone
    }

    const lacks = missingFields(draft)
    if (lacks.length > 0) {
      return NextResponse.json({
        response: `–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –¥–µ—Ç–∞–ª–µ–π: ${lacks.join(', ')}. –ù–∞–ø–∏—à–∏—Ç–µ –æ–¥–Ω–æ–π —Ñ—Ä–∞–∑–æ–π, –∏ —Å–æ–±–µ—Ä—É —Å—Å—ã–ª–∫—É –Ω–∞ —á–µ—Ä–Ω–æ–≤–∏–∫.`,
        suggestions: ['–î–∞—Ç–∞, –≤—Ä–µ–º—è, –∞–¥—Ä–µ—Å, –±—é–¥–∂–µ—Ç', '–î–æ–±–∞–≤—å—Ç–µ —Ä–æ–ª—å –∏ —Ç–∏–ø –ø–ª–æ—â–∞–¥–∫–∏'],
        gallery: [],
      })
    }

    const softLacks = optionalMissing(draft)
    if (softLacks.length > 0) {
      return NextResponse.json({
        response: `–ü–æ—á—Ç–∏ –≥–æ—Ç–æ–≤–æ. –ù—É–∂–Ω—ã —É—Ç–æ—á–Ω–µ–Ω–∏—è: ${softLacks.join(', ')}. –ù–∞–ø–∏—à–∏—Ç–µ –æ–¥–Ω–æ–π —Ñ—Ä–∞–∑–æ–π, –∏ —Å—Ä–∞–∑—É —Å–æ–±–µ—Ä—É —Å—Å—ã–ª–∫—É –Ω–∞ —á–µ—Ä–Ω–æ–≤–∏–∫.`,
        suggestions: ['–î–µ—Ç–µ–π 10-12 –ª–µ—Ç, 15 —á–µ–ª–æ–≤–µ–∫', '–û–ø–∏—Å–∞–Ω–∏–µ: –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤ —Å —Ñ–æ–∫—É—Å–∞–º–∏', '–¢–µ–ª–µ—Ñ–æ–Ω: +7 ...'],
        gallery: [],
      })
    }

    const encoded = encodePrefill(draft)
    if (!encoded) {
      return NextResponse.json({
        response: '–ù–µ —É–¥–∞–ª–æ—Å—å —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å —á–µ—Ä–Ω–æ–≤–∏–∫. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –∫–ª—é—á–µ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–¥–Ω–æ–π —Ñ—Ä–∞–∑–æ–π (–¥–∞—Ç–∞, –≤—Ä–µ–º—è, —Ä–æ–ª—å, –∞–¥—Ä–µ—Å, –±—é–¥–∂–µ—Ç, –¥–µ—Ç–∏).',
        suggestions: ['25 –¥–µ–∫–∞–±—Ä—è 17:00 —Ñ–æ–∫—É—Å–Ω–∏–∫, —Ä–µ—Å—Ç–æ—Ä–∞–Ω..., –±—é–¥–∂–µ—Ç 15000, –¥–µ—Ç–µ–π 10, 7 –ª–µ—Ç'],
        gallery: [],
      })
    }

    const link = `/create-request?prefill=${encoded}`
    return NextResponse.json({
      response: `–°–æ–±—Ä–∞–ª —á–µ—Ä–Ω–æ–≤–∏–∫ –∑–∞—è–≤–∫–∏.\n\n${makeSummary(draft)}\n\n[–û—Ç–∫—Ä—ã—Ç—å —á–µ—Ä–Ω–æ–≤–∏–∫](${link}) ‚Äî –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–µ—Ç–∞–ª–∏ –∏ –æ–ø—É–±–ª–∏–∫—É–π—Ç–µ.`,
      suggestions: ['–ò–∑–º–µ–Ω–∏—Ç—å –±—é–¥–∂–µ—Ç', '–ü–æ–º–µ–Ω—è—Ç—å –≤—Ä–µ–º—è', '–î–æ–±–∞–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã'],
      gallery: [],
    })
  } catch (error) {
    console.error('[RequestDraftChat] error', error)
    return NextResponse.json({ error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞' }, { status: 500 })
  }
}












