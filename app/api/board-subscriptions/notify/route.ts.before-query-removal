// TODO: MIGRATE QUERIES TO PRISMA
// –≠—Ç–æ—Ç —Ñ–∞–π–ª —á–∞—Å—Ç–∏—á–Ω–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç Supabase queries
// –û–Ω–∏ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –ø–æ–ª–Ω–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'
import { logger } from '@/lib/logger'

const SITE_URL = process.env.NEXT_PUBLIC_SITE_URL || 'https://zumzam.ru'
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN

/**
 * POST /api/board-subscriptions/notify
 * –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º –æ –Ω–æ–≤–æ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–∏
 * 
 * –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è
 */
export async function POST(request: NextRequest) {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º API –∫–ª—é—á –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –≤—ã–∑–æ–≤–æ–≤
    const apiKey = request.headers.get('x-api-key')
    if (apiKey !== process.env.INTERNAL_API_KEY) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const { requestId } = await request.json()

    if (!requestId) {
      return NextResponse.json({ error: 'requestId required' }, { status: 400 })
    }

    // Supabase client removed

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    const { data: orderRequest, error: requestError } = await supabase
      .from('order_requests')
      .select('*')
      .eq('id', requestId)
      .single()

    if (requestError || !orderRequest) {
      logger.error('[Notify Subscribers] Request not found', { requestId, error: requestError })
      return NextResponse.json({ error: 'Request not found' }, { status: 404 })
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ –ë–î –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø–æ–¥–ø–∏—Å–æ–∫
    const { data: matchingSubscriptions, error: matchError } = await supabase
      .rpc('get_matching_subscriptions', { request_id: requestId })

    if (matchError) {
      logger.error('[Notify Subscribers] Error getting matching subscriptions', { matchError })
      return NextResponse.json({ error: 'Failed to get subscriptions' }, { status: 500 })
    }

    if (!matchingSubscriptions || matchingSubscriptions.length === 0) {
      logger.info('[Notify Subscribers] No matching subscriptions', { requestId })
      return NextResponse.json({ sent: 0, subscriptions: 0 })
    }

    logger.info('[Notify Subscribers] Found matching subscriptions', { 
      requestId, 
      count: matchingSubscriptions.length 
    })

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏
    const stats = {
      internal: 0,
      email: 0,
      telegram: 0,
      push: 0,
      errors: 0,
    }

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –ø–æ–¥–ø–∏—Å–∫—É
    for (const sub of matchingSubscriptions) {
      try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏ –ª–∏ —É–∂–µ
        const { data: existing } = await supabase
          .from('board_subscription_notifications')
          .select('id')
          .eq('subscription_id', sub.subscription_id)
          .eq('request_id', requestId)
          .single()

        if (existing) continue // –£–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–ª–∏

        const notificationRecord: Record<string, any> = {
          subscription_id: sub.subscription_id,
          request_id: requestId,
        }

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        if (sub.notify_internal) {
          try {
            await createInternalNotification(supabase, sub.user_id, orderRequest)
            notificationRecord.internal_sent_at = new Date().toISOString()
            stats.internal++
          } catch (e) {
            logger.error('[Notify Subscribers] Internal notification failed', { error: e })
          }
        }

        // Push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        if (sub.notify_push) {
          try {
            await sendPushNotification(sub.user_id, orderRequest)
            notificationRecord.push_sent_at = new Date().toISOString()
            stats.push++
          } catch (e) {
            logger.error('[Notify Subscribers] Push notification failed', { error: e })
          }
        }

        // Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
        if (sub.notify_telegram) {
          try {
            await sendTelegramNotification(supabase, sub.user_id, orderRequest)
            notificationRecord.telegram_sent_at = new Date().toISOString()
            stats.telegram++
          } catch (e) {
            logger.error('[Notify Subscribers] Telegram notification failed', { error: e })
          }
        }

        // Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ–µ)
        if (sub.notify_email && sub.email_frequency === 'instant') {
          try {
            await sendEmailNotification(supabase, sub.user_id, orderRequest)
            notificationRecord.email_sent_at = new Date().toISOString()
            stats.email++
          } catch (e) {
            logger.error('[Notify Subscribers] Email notification failed', { error: e })
          }
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–ø–∏—Å—å –æ–± —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–∏
        await supabase
          .from('board_subscription_notifications')
          .insert(notificationRecord)

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ–¥–ø–∏—Å–∫–∏
        await supabase
          .from('board_subscriptions')
          .update({ 
            matches_count: (await supabase
              .from('board_subscriptions')
              .select('matches_count')
              .eq('id', sub.subscription_id)
              .single()
            ).data?.matches_count || 0 + 1,
            last_matched_at: new Date().toISOString(),
          })
          .eq('id', sub.subscription_id)

      } catch (e) {
        logger.error('[Notify Subscribers] Error processing subscription', { 
          subscriptionId: sub.subscription_id, 
          error: e 
        })
        stats.errors++
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    await supabase
      .from('order_requests')
      .update({ subscribers_notified_at: new Date().toISOString() })
      .eq('id', requestId)

    logger.info('[Notify Subscribers] Notifications sent', { requestId, stats })

    return NextResponse.json({ 
      success: true,
      subscriptions: matchingSubscriptions.length,
      sent: stats,
    })
  } catch (error) {
    logger.error('[Notify Subscribers] Unexpected error', { error })
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
 */
async function createInternalNotification(
  supabase: any, 
  userId: string, 
  request: any
) {
  await prisma.notifications.insert({
    user_id: userId,
    type: 'system',
    title: '–ù–æ–≤–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–µ',
    body: request.title || `–ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ ${request.category}`,
    action_url: `/board/${request.id}`,
    read: false,
    read_at: null,
    data: {
      request_id: request.id,
      category: request.category,
      source: 'board_subscription',
    },
  })
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ Push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
 */
async function sendPushNotification(userId: string, request: any) {
  await fetch(`${SITE_URL}/api/push/send`, {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      'x-api-key': process.env.INTERNAL_API_KEY || '',
    },
    body: JSON.stringify({
      userId,
      title: '–ù–æ–≤–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ –ø–æ–¥–ø–∏—Å–∫–µ',
      body: request.title || `${request.category} ‚Äî ${request.city}`,
      url: `/board/${request.id}`,
      data: { requestId: request.id },
    }),
  })
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ Telegram —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
 */
async function sendTelegramNotification(
  supabase: any, 
  userId: string, 
  request: any
) {
  if (!TELEGRAM_BOT_TOKEN) return

  // –ü–æ–ª—É—á–∞–µ–º telegram_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const { data: telegramUser } = await supabase
    .from('telegram_users')
    .select('telegram_id')
    .eq('user_id', userId)
    .eq('is_active', true)
    .single()

  if (!telegramUser?.telegram_id) return

  const message = `üîî <b>–ù–æ–≤–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–µ</b>\n\n` +
    `üìã ${request.title || request.category}\n` +
    `üìç ${request.city}${request.district ? `, ${request.district}` : ''}\n` +
    `${request.budget ? `üí∞ ${request.budget.toLocaleString('ru-RU')} ‚ÇΩ\n` : ''}` +
    `\nüîó <a href="${SITE_URL}/board/${request.id}">–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ —Å–∞–π—Ç–µ</a>`

  await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: telegramUser.telegram_id,
      text: message,
      parse_mode: 'HTML',
      disable_web_page_preview: true,
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üìã –ü–æ–¥—Ä–æ–±–Ω–µ–µ', url: `${SITE_URL}/board/${request.id}` },
          ],
        ],
      },
    }),
  })
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
 */
async function sendEmailNotification(
  supabase: any, 
  userId: string, 
  request: any
) {
  // –ü–æ–ª—É—á–∞–µ–º email –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
  const { data: { user } } = await supabase.auth.admin.getUserById(userId)
  
  if (!user?.email) return

  // TODO: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å email-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–º (Resend, SendGrid –∏ —Ç.–¥.)
  // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
  logger.info('[Email Notification] Would send email', {
    to: user.email,
    subject: '–ù–æ–≤–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ –≤–∞—à–µ–π –ø–æ–¥–ø–∏—Å–∫–µ',
    requestId: request.id,
  })
}






