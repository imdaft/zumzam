// TODO: MIGRATE TO PRISMA - —ç—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Supabase queries
// –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma –¥–ª—è consistency

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'
import { logger } from '@/lib/logger'
import { 
  formatRequestHashtags, 
  TELEGRAM_CATEGORY_HASHTAGS,
} from '@/lib/types/board-subscription'
import { CATEGORIES, CLIENT_TYPES } from '@/lib/types/order-request'

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN
const TELEGRAM_CHANNEL_ID = process.env.TELEGRAM_CHANNEL_ID // –Ω–∞–ø—Ä–∏–º–µ—Ä: @zumzam_orders –∏–ª–∏ -1001234567890
const SITE_URL = process.env.NEXT_PUBLIC_SITE_URL || 'https://zumzam.ru'

/**
 * POST /api/telegram/publish-request
 * –ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –≤ Telegram-–∫–∞–Ω–∞–ª
 */
export async function POST(request: NextRequest) {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º API –∫–ª—é—á –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –≤—ã–∑–æ–≤–æ–≤
    const apiKey = request.headers.get('x-api-key')
    if (apiKey !== process.env.INTERNAL_API_KEY) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    if (!TELEGRAM_BOT_TOKEN || !TELEGRAM_CHANNEL_ID) {
      logger.warn('[Telegram Publish] Bot token or channel ID not configured')
      return NextResponse.json({ error: 'Telegram not configured' }, { status: 500 })
    }

    const { requestId } = await request.json()

    if (!requestId) {
      return NextResponse.json({ error: 'requestId required' }, { status: 400 })
    }

    // Supabase client removed

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    const { data: orderRequest, error } = await supabase
      .from('order_requests')
      .select('*')
      .eq('id', requestId)
      .single()

    if (error || !orderRequest) {
      logger.error('[Telegram Publish] Request not found', { requestId, error })
      return NextResponse.json({ error: 'Request not found' }, { status: 404 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ –ª–∏ —É–∂–µ
    const { data: existingPost } = await supabase
      .from('telegram_request_posts')
      .select('id')
      .eq('request_id', requestId)
      .single()

    if (existingPost) {
      return NextResponse.json({ 
        error: 'Already published',
        postId: existingPost.id 
      }, { status: 409 })
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    const message = formatTelegramMessage(orderRequest)

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ Telegram
    const telegramResponse = await fetch(
      `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`,
      {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: TELEGRAM_CHANNEL_ID,
          text: message,
          parse_mode: 'HTML',
          disable_web_page_preview: false,
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'üìã –ü–æ–¥—Ä–æ–±–Ω–µ–µ', url: `${SITE_URL}/board/${requestId}` },
                { text: '‚úâÔ∏è –û—Ç–∫–ª–∏–∫–Ω—É—Ç—å—Å—è', url: `${SITE_URL}/board/${requestId}#respond` },
              ],
            ],
          },
        }),
      }
    )

    const telegramResult = await telegramResponse.json()

    if (!telegramResult.ok) {
      logger.error('[Telegram Publish] Failed to send message', { 
        requestId, 
        error: telegramResult 
      })
      return NextResponse.json({ 
        error: 'Failed to publish to Telegram',
        details: telegramResult.description 
      }, { status: 500 })
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏
    const { data: post, error: postError } = await supabase
      .from('telegram_request_posts')
      .insert({
        request_id: requestId,
        message_id: telegramResult.result.message_id,
        channel_id: TELEGRAM_CHANNEL_ID,
        posted_at: new Date().toISOString(),
      })
      .select()
      .single()

    if (postError) {
      logger.error('[Telegram Publish] Failed to save post record', { postError })
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
    await supabase
      .from('order_requests')
      .update({ telegram_posted_at: new Date().toISOString() })
      .eq('id', requestId)

    logger.info('[Telegram Publish] Request published', { 
      requestId, 
      messageId: telegramResult.result.message_id 
    })

    return NextResponse.json({ 
      success: true,
      messageId: telegramResult.result.message_id,
      postId: post?.id,
    })
  } catch (error) {
    logger.error('[Telegram Publish] Unexpected error', { error })
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

/**
 * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è Telegram
 */
function formatTelegramMessage(request: {
  id: string
  client_type: string
  category: string
  title: string
  description?: string
  event_date: string
  event_time?: string
  city: string
  district?: string
  children_count?: number
  children_age_from?: number
  children_age_to?: number
  budget?: number
  budget_negotiable?: boolean
  is_urgent: boolean
  details?: Record<string, any>
  listing_plan_id?: string
}): string {
  // –•–µ—à—Ç–µ–≥–∏
  const hashtags = formatRequestHashtags({
    category: request.category as any,
    city: request.city,
    is_urgent: request.is_urgent,
    client_type: request.client_type as any,
    listing_plan_id: request.listing_plan_id,
  })

  // –≠–º–æ–¥–∑–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
  const categoryInfo = CATEGORIES.find(c => c.id === request.category)
  const categoryEmoji = categoryInfo?.emoji || '‚ú®'

  // –¢–∏–ø –∑–∞–∫–∞–∑—á–∏–∫–∞
  const clientTypeInfo = CLIENT_TYPES.find(c => c.id === request.client_type)
  const clientTypeLabel = clientTypeInfo 
    ? `${clientTypeInfo.emoji} ${clientTypeInfo.label}`
    : 'üë§ –ö–ª–∏–µ–Ω—Ç'

  // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
  let message = `üì¢ <b>–ù–û–í–ê–Ø –ó–ê–Ø–í–ö–ê</b> ${hashtags.join(' ')}\n\n`

  // –¢–∏–ø –∑–∞–∫–∞–∑—á–∏–∫–∞
  message += `${clientTypeLabel}\n`

  // –ú–µ—Å—Ç–æ
  message += `üìç ${request.city}`
  if (request.district) {
    message += `, ${request.district}`
  }
  message += '\n'

  // –î–∞—Ç–∞
  const date = new Date(request.event_date)
  const dateStr = date.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long' })
  message += `üìÖ ${dateStr}`
  if (request.event_time) {
    message += `, ${request.event_time}`
  }
  message += '\n'

  // –î–µ—Ç–∏
  if (request.children_count) {
    message += `üëß ${request.children_count} ${pluralize(request.children_count, '—Ä–µ–±—ë–Ω–æ–∫', '—Ä–µ–±—ë–Ω–∫–∞', '–¥–µ—Ç–µ–π')}`
    if (request.children_age_from && request.children_age_to) {
      message += `, ${request.children_age_from}‚Äì${request.children_age_to} –ª–µ—Ç`
    }
    message += '\n'
  }

  // –ë—é–¥–∂–µ—Ç
  if (request.budget) {
    message += `üí∞ –ë—é–¥–∂–µ—Ç: ${request.budget.toLocaleString('ru-RU')} ‚ÇΩ`
    if (request.budget_negotiable) {
      message += ' (–¥–æ–≥–æ–≤–æ—Ä–Ω–æ–π)'
    }
    message += '\n'
  } else if (request.budget_negotiable) {
    message += `üí∞ –ë—é–¥–∂–µ—Ç: –¥–æ–≥–æ–≤–æ—Ä–Ω–æ–π\n`
  }

  message += '\n'

  // –ó–∞–≥–æ–ª–æ–≤–æ–∫
  if (request.title) {
    message += `<b>${escapeHtml(request.title)}</b>\n`
  }

  // –û–ø–∏—Å–∞–Ω–∏–µ (—É—Ä–µ–∑–∞–Ω–Ω–æ–µ)
  if (request.description) {
    const desc = request.description.slice(0, 300)
    message += escapeHtml(desc)
    if (request.description.length > 300) {
      message += '...'
    }
    message += '\n'
  }

  // –î–µ—Ç–∞–ª–∏
  const details = request.details || {}
  const detailsLines: string[] = []
  
  if (details.hasOwnCostume) detailsLines.push('‚úÖ –ö–æ—Å—Ç—é–º —Å–≤–æ–π')
  if (details.hasOwnProps) detailsLines.push('‚úÖ –†–µ–∫–≤–∏–∑–∏—Ç —Å–≤–æ–π')
  if (details.hasOwnSpeaker) detailsLines.push('‚úÖ –ö–æ–ª–æ–Ω–∫–∞ —Å–≤–æ—è')
  if (details.speakerProvided) detailsLines.push('üîä –ö–æ–ª–æ–Ω–∫–∞ –±—É–¥–µ—Ç –Ω–∞ –º–µ—Å—Ç–µ')
  if (details.character) detailsLines.push(`üé≠ –ü–µ—Ä—Å–æ–Ω–∞–∂: ${details.character}`)

  if (detailsLines.length > 0) {
    message += '\n' + detailsLines.join('\n')
  }

  return message.trim()
}

/**
 * –°–∫–ª–æ–Ω–µ–Ω–∏–µ —Å–ª–æ–≤
 */
function pluralize(n: number, one: string, few: string, many: string): string {
  const mod10 = n % 10
  const mod100 = n % 100

  if (mod100 >= 11 && mod100 <= 19) return many
  if (mod10 === 1) return one
  if (mod10 >= 2 && mod10 <= 4) return few
  return many
}

/**
 * –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ HTML –¥–ª—è Telegram
 */
function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}






