// TODO: MIGRATE TO PRISMA - —ç—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Supabase queries
// –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma –¥–ª—è consistency

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'

// –ü—Ä–∏–≤—è–∑–∫–∞ Telegram –ø–æ –∫–æ–¥—É
export async function POST(request: NextRequest) {
  try {
    // Supabase client removed
    
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub
    // Auth check done above, { status: 401 })
    }
    
    const { code } = await request.json()
    
    if (!code) {
      return NextResponse.json({ error: 'Code is required' }, { status: 400 })
    }
    
    // –ò—â–µ–º –∫–æ–¥
    const { data: connectCode, error: codeError } = await supabase
      .from('telegram_connect_codes')
      .select('*')
      .eq('code', code.toUpperCase())
      .gt('expires_at', new Date().toISOString())
      .is('used_at', null)
      .single()
    
    if (codeError || !connectCode) {
      return NextResponse.json({ 
        error: '–ö–æ–¥ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –∏–ª–∏ –∏—Å—Ç—ë–∫. –ü–æ–ª—É—á–∏—Ç–µ –Ω–æ–≤—ã–π –∫–æ–¥ –≤ Telegram –±–æ—Ç–µ.' 
      }, { status: 400 })
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç Telegram –∫ –¥—Ä—É–≥–æ–º—É –∞–∫–∫–∞—É–Ω—Ç—É
    const { data: existingTelegram } = await supabase
      .from('telegram_users')
      .select('user_id')
      .eq('telegram_id', connectCode.telegram_id)
      .single()
    
    if (existingTelegram && existingTelegram.user_id !== userId) {
      return NextResponse.json({ 
        error: '–≠—Ç–æ—Ç Telegram —É–∂–µ –ø—Ä–∏–≤—è–∑–∞–Ω –∫ –¥—Ä—É–≥–æ–º—É –∞–∫–∫–∞—É–Ω—Ç—É' 
      }, { status: 400 })
    }
    
    // –°–æ–∑–¥–∞—ë–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å telegram_users
    const { error: upsertError } = await supabase
      .from('telegram_users')
      .upsert({
        telegram_id: connectCode.telegram_id,
        telegram_username: connectCode.telegram_username,
        user_id: userId,
        notify_new_requests: true,
        notify_messages: true,
        notify_order_status: true,
        is_active: true,
        updated_at: new Date().toISOString(),
      }, {
        onConflict: 'telegram_id',
      })
    
    // Error handling removed (Prisma throws exceptions), { status: 500 })
    }
    
    // –ü–æ–º–µ—á–∞–µ–º –∫–æ–¥ –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
    await supabase
      .from('telegram_connect_codes')
      .update({ used_at: new Date().toISOString() })
      .eq('id', connectCode.id)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
    const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN
    if (BOT_TOKEN) {
      await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: connectCode.telegram_id,
          text: `‚úÖ <b>–ê–∫–∫–∞—É–Ω—Ç —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–≤—è–∑–∞–Ω!</b>\n\n–¢–µ–ø–µ—Ä—å –≤—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ:\n‚Ä¢ –ù–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏—è—Ö –ø–æ –≤–∞—à–∏–º –ø–æ–¥–ø–∏—Å–∫–∞–º\n‚Ä¢ –û—Ç–∫–ª–∏–∫–∞—Ö –Ω–∞ –≤–∞—à–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏—è\n‚Ä¢ –ù–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏—è—Ö`,
          parse_mode: 'HTML',
        }),
      })
    }
    
    return NextResponse.json({ 
      success: true,
      telegram_username: connectCode.telegram_username,
    })
  } catch (error) {
    console.error('Telegram connect error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// –û—Ç–≤—è–∑–∫–∞ Telegram
export async function DELETE(request: NextRequest) {
  try {
    // Supabase client removed
    
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub
    // Auth check done above, { status: 401 })
    }
    
    // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–π Telegram
    const { data: telegramUser } = await supabase
      .from('telegram_users')
      .select('telegram_id')
      .eq('user_id', userId)
      .single()
    
    if (!telegramUser) {
      return NextResponse.json({ error: 'Telegram –Ω–µ –ø—Ä–∏–≤—è–∑–∞–Ω' }, { status: 400 })
    }
    
    // –£–¥–∞–ª—è–µ–º –ø—Ä–∏–≤—è–∑–∫—É
    await supabase
      .from('telegram_users')
      .delete()
      .eq('user_id', userId)
    
    // –£–≤–µ–¥–æ–º–ª—è–µ–º –≤ Telegram
    const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN
    if (BOT_TOKEN && telegramUser.telegram_id) {
      await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          chat_id: telegramUser.telegram_id,
          text: `üîì –í–∞—à Telegram –æ—Ç–≤—è–∑–∞–Ω –æ—Ç –∞–∫–∫–∞—É–Ω—Ç–∞ ZumZam.\n\n–í—ã –±–æ–ª—å—à–µ –Ω–µ –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.`,
          parse_mode: 'HTML',
        }),
      })
    }
    
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Telegram disconnect error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≤—è–∑–∫–∏
export async function GET(request: NextRequest) {
  try {
    // Supabase client removed
    
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub
    // Auth check done above, { status: 401 })
    }
    
    const { data: telegramUser } = await supabase
      .from('telegram_users')
      .select('telegram_id, telegram_username, notify_new_requests, notify_messages, notify_order_status, is_active')
      .eq('user_id', userId)
      .single()
    
    return NextResponse.json({
      connected: !!telegramUser,
      telegram_username: telegramUser?.telegram_username,
      settings: telegramUser ? {
        notify_new_requests: telegramUser.notify_new_requests,
        notify_messages: telegramUser.notify_messages,
        notify_order_status: telegramUser.notify_order_status,
        is_active: telegramUser.is_active,
      } : null,
    })
  } catch (error) {
    console.error('Telegram status error:', error)
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}






