import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { logger } from '@/lib/logger'

/**
 * GET /api/admin/moderation/stats
 * Статистика для дашборда модерации
 */
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    // Проверяем авторизацию
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Проверяем роль администратора
    const { data: userData } = await supabase
      .from('users')
      .select('role')
      .eq('id', user.id)
      .single()

    if (!userData || userData.role !== 'admin') {
      return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
    }

    // Статистика профилей
    const { count: pendingProfiles } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true })
      .eq('is_published', false)
      .is('verified', false)

    const { count: approvedProfiles } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true })
      .eq('is_published', true)

    const { count: totalProfiles } = await supabase
      .from('profiles')
      .select('*', { count: 'exact', head: true })

    // Статистика отзывов
    const { count: pendingReviews } = await supabase
      .from('reviews')
      .select('*', { count: 'exact', head: true })
      .eq('moderated', false)

    const { count: approvedReviews } = await supabase
      .from('reviews')
      .select('*', { count: 'exact', head: true })
      .eq('moderated', true)
      .eq('visible', true)

    const { count: rejectedReviews } = await supabase
      .from('reviews')
      .select('*', { count: 'exact', head: true })
      .eq('moderated', true)
      .eq('visible', false)

    const { count: totalReviews } = await supabase
      .from('reviews')
      .select('*', { count: 'exact', head: true })

    // Статистика жалоб (если таблица существует)
    let reportsStats = { open: 0, resolved: 0, total: 0 }
    try {
      const { count: openReports } = await supabase
        .from('reports')
        .select('*', { count: 'exact', head: true })
        .eq('status', 'open')

      const { count: resolvedReports } = await supabase
        .from('reports')
        .select('*', { count: 'exact', head: true })
        .eq('status', 'resolved')

      const { count: totalReports } = await supabase
        .from('reports')
        .select('*', { count: 'exact', head: true })

      reportsStats = {
        open: openReports || 0,
        resolved: resolvedReports || 0,
        total: totalReports || 0
      }
    } catch {
      // Таблица reports может не существовать
    }

    // Последние действия модерации
    let recentActions: any[] = []
    try {
      const { data: actions } = await supabase
        .from('moderation_log')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(10)

      recentActions = actions || []
    } catch {
      // Таблица moderation_log может не существовать
    }

    logger.debug('[Moderation API] Stats fetched')

    return NextResponse.json({
      profiles: {
        pending: pendingProfiles || 0,
        approved: approvedProfiles || 0,
        rejected: (totalProfiles || 0) - (approvedProfiles || 0) - (pendingProfiles || 0),
        total: totalProfiles || 0
      },
      reviews: {
        pending: pendingReviews || 0,
        approved: approvedReviews || 0,
        rejected: rejectedReviews || 0,
        total: totalReviews || 0
      },
      reports: reportsStats,
      recentActions
    })

  } catch (error: any) {
    logger.error('[Moderation API] Stats error', error)
    return NextResponse.json(
      { error: 'Internal error' },
      { status: 500 }
    )
  }
}

