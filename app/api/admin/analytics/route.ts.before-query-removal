// TODO: MIGRATE QUERIES TO PRISMA
// Этот файл частично мигрирован, но содержит Supabase queries
// Они будут работать, но требуют полной миграции на Prisma

import { NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'

export const dynamic = 'force-dynamic'

/**
 * GET /api/admin/analytics
 * Получить общую аналитику платформы
 */
export async function GET() {
  try {
    // Supabase client removed
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub

    // Auth check done above, { status: 401 })
    }

    // Проверяем роль админа
    const { data: userData, error: userRoleError } = await supabase
      .from('users')
      .select('role')
      .eq('id', userId)
      .single()

    if (userRoleError || userData?.role !== 'admin') {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    // Параллельно запрашиваем всю статистику
    const [
      usersStats,
      profilesStats,
      reviewsStats,
      ordersStats,
    ] = await Promise.all([
      // Статистика пользователей
      Promise.all([
        prisma.users.select('id', { count: 'exact', head: true }),
        prisma.users.select('id', { count: 'exact', head: true }).eq('role', 'client'),
        prisma.users.select('id', { count: 'exact', head: true }).eq('role', 'provider'),
        prisma.users.select('id', { count: 'exact', head: true }).eq('role', 'admin'),
      ]).then(([total, clients, providers, admins]) => ({
        total: total.count || 0,
        clients: clients.count || 0,
        providers: providers.count || 0,
        admins: admins.count || 0,
      })),

      // Статистика профилей
      Promise.all([
        prisma.profiles.select('id', { count: 'exact', head: true }),
        prisma.profiles.select('id', { count: 'exact', head: true }).eq('is_published', true),
        prisma.profiles.select('id', { count: 'exact', head: true }).eq('is_verified', true),
      ]).then(([total, published, verified]) => ({
        total: total.count || 0,
        published: published.count || 0,
        verified: verified.count || 0,
      })),

      // Статистика отзывов
      Promise.all([
        prisma.reviews.select('id', { count: 'exact', head: true }),
        prisma.reviews.select('id', { count: 'exact', head: true }).eq('status', 'approved'),
        prisma.reviews.select('id', { count: 'exact', head: true }).eq('status', 'pending'),
        prisma.reviews.select('id', { count: 'exact', head: true }).eq('status', 'rejected'),
      ]).then(([total, approved, pending, rejected]) => ({
        total: total.count || 0,
        approved: approved.count || 0,
        pending: pending.count || 0,
        rejected: rejected.count || 0,
      })),

      // Статистика заказов
      Promise.all([
        prisma.orders.select('id', { count: 'exact', head: true }),
        prisma.orders.select('id', { count: 'exact', head: true }).eq('status', 'pending'),
        prisma.orders.select('id', { count: 'exact', head: true }).eq('status', 'confirmed'),
        prisma.orders.select('id', { count: 'exact', head: true }).eq('status', 'completed'),
        prisma.orders.select('id', { count: 'exact', head: true }).eq('status', 'cancelled'),
      ]).then(([total, pending, confirmed, completed, cancelled]) => ({
        total: total.count || 0,
        pending: pending.count || 0,
        confirmed: confirmed.count || 0,
        completed: completed.count || 0,
        cancelled: cancelled.count || 0,
      })),
    ])

    // Получаем динамику за последние 30 дней
    const thirtyDaysAgo = new Date()
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

    const [recentUsers, recentProfiles, recentOrders] = await Promise.all([
      supabase
        .from('users')
        .select('created_at')
        .gte('created_at', thirtyDaysAgo.toISOString())
        .order('created_at', { ascending: true }),
      supabase
        .from('profiles')
        .select('created_at')
        .gte('created_at', thirtyDaysAgo.toISOString())
        .order('created_at', { ascending: true }),
      supabase
        .from('orders')
        .select('created_at, total_amount')
        .gte('created_at', thirtyDaysAgo.toISOString())
        .order('created_at', { ascending: true }),
    ])

    // Группируем по дням
    const groupByDay = (items: any[], field: string = 'created_at') => {
      const grouped: Record<string, number> = {}
      items.forEach((item) => {
        const date = new Date(item[field]).toISOString().split('T')[0]
        grouped[date] = (grouped[date] || 0) + 1
      })
      return grouped
    }

    const usersTimeline = groupByDay(recentUsers.data || [])
    const profilesTimeline = groupByDay(recentProfiles.data || [])
    const ordersTimeline = groupByDay(recentOrders.data || [])

    // Общая сумма заказов
    const totalRevenue = (recentOrders.data || []).reduce((sum, order) => sum + (order.total_amount || 0), 0)

    // Статистика посещаемости — используем реальную таблицу user_activity (её пишет трекер)
    const todayStartIso = new Date(new Date().setHours(0, 0, 0, 0)).toISOString()
    const thirtyDaysAgoIso = thirtyDaysAgo.toISOString()
    const fiveMinutesAgoIso = new Date(Date.now() - 5 * 60 * 1000).toISOString()

    const [pageViews30d, pageViewsOnline, pageViewsToday] = await Promise.all([
      supabase
        .from('user_activity')
        .select('created_at, session_id', { count: 'exact' })
        .eq('action_type', 'page_view')
        .gte('created_at', thirtyDaysAgoIso)
        .order('created_at', { ascending: true })
        .limit(100000),

      supabase
        .from('user_activity')
        .select('session_id')
        .eq('action_type', 'page_view')
        .gte('created_at', fiveMinutesAgoIso)
        .limit(100000),

      supabase
        .from('user_activity')
        .select('session_id, device_type')
        .eq('action_type', 'page_view')
        .gte('created_at', todayStartIso)
        .limit(100000),
    ])

    const sessions30d = new Set((pageViews30d.data || []).map((e: any) => e.session_id))
    const sessionsOnline = new Set((pageViewsOnline.data || []).map((e: any) => e.session_id))
    const sessionsToday = new Set((pageViewsToday.data || []).map((e: any) => e.session_id))

    const todayEvents = pageViewsToday.data || []
    const todayStats = {
      pageviews: todayEvents.length,
      unique_visitors: sessionsToday.size,
      mobile: todayEvents.filter((e: any) => e.device_type === 'mobile').length,
      desktop: todayEvents.filter((e: any) => e.device_type === 'desktop').length,
    }

    const visitorsTimeline: Record<string, number> = {}
    for (const visit of (pageViews30d.data || []) as any[]) {
      const date = new Date(visit.created_at).toISOString().split('T')[0]
      visitorsTimeline[date] = (visitorsTimeline[date] || 0) + 1
    }

    return NextResponse.json({
      users: usersStats,
      profiles: profilesStats,
      reviews: reviewsStats,
      orders: ordersStats,
      timelines: {
        users: usersTimeline,
        profiles: profilesTimeline,
        orders: ordersTimeline,
        visitors: visitorsTimeline,
      },
      revenue: {
        total: totalRevenue,
        last30Days: totalRevenue,
      },
      traffic: {
        unique_visitors_30d: sessions30d.size,
        online_now: sessionsOnline.size,
        today: todayStats,
      },
    })
  } catch (error: any) {
    logger.error('Admin analytics GET error:', error)
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

