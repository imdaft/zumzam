import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

// GET /api/conversations — получить все диалоги пользователя
// ОПТИМИЗИРОВАНО: batch-запросы вместо N+1
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Необходимо авторизоваться' }, { status: 401 })
    }

    // 1. Получаем все диалоги пользователя
    const { data: conversations, error } = await supabase
      .from('conversations')
      .select(`
        *,
        profiles (
          id,
          slug,
          display_name,
          main_photo,
          logo,
          photos,
          user_id
        )
      `)
      .or(`participant_1_id.eq.${user.id},participant_2_id.eq.${user.id}`)
      .order('last_message_at', { ascending: false, nullsFirst: false })

    if (error) {
      console.error('[API Conversations] Error fetching:', error)
      return NextResponse.json({ error: 'Ошибка получения диалогов' }, { status: 500 })
    }

    if (!conversations || conversations.length === 0) {
      return NextResponse.json({ conversations: [] })
    }

    // Собираем все ID для batch-запросов
    const otherParticipantIds = new Set<string>()
    const requestSourceIds: string[] = []
    const orderSourceIds: string[] = []
    const conversationIds = conversations.map(c => c.id)

    conversations.forEach(conv => {
      const otherId = conv.participant_1_id === user.id ? conv.participant_2_id : conv.participant_1_id
      if (otherId) otherParticipantIds.add(otherId)
      
      if (conv.source_type === 'request' && conv.source_id) {
        requestSourceIds.push(conv.source_id)
      }
      if (conv.source_type === 'order' && conv.source_id) {
        orderSourceIds.push(conv.source_id)
      }
    })

    // 2. ПАРАЛЛЕЛЬНЫЕ batch-запросы вместо N отдельных
    const [usersResult, unreadResult, requestsResult, ordersResult, folderLinksResult] = await Promise.all([
      // Все собеседники одним запросом
      otherParticipantIds.size > 0
        ? supabase
          .from('users')
          .select('id, full_name, avatar_url')
            .in('id', Array.from(otherParticipantIds))
        : Promise.resolve({ data: [] }),

      // Непрочитанные сообщения - агрегация одним запросом
      supabase
          .from('messages')
        .select('conversation_id')
        .in('conversation_id', conversationIds)
          .neq('sender_id', user.id)
        .is('read_at', null),
      
      // Все order_requests одним запросом
      requestSourceIds.length > 0
        ? supabase
            .from('order_requests')
            .select('id, title, category, status, event_date, event_time, city, budget, client_type, client_id')
            .in('id', requestSourceIds)
        : Promise.resolve({ data: [] }),
      
      // Все orders одним запросом
      orderSourceIds.length > 0
        ? supabase
            .from('orders')
            .select(`
              id, 
              order_number,
              status, 
              total_amount, 
              event_date, 
              event_time, 
              event_address,
              client_name,
              client_id,
              provider_id,
              profile:profiles (
                id,
                display_name,
                main_photo,
                logo
              )
            `)
            .in('id', orderSourceIds)
        : Promise.resolve({ data: [] }),

      // Ссылки на папки
      supabase
        .from('conversation_folder_links')
        .select('conversation_id, folder_id')
        .in('conversation_id', conversationIds)
        // Важно: фильтруем только ссылки текущего пользователя (через join с папками)
        // Но так как у нас RLS на чтение ссылок (проверяет владельца папки), 
        // то простой select вернет только доступные ссылки.
        // Но для уверенности, что это именно папки этого юзера (а не общие, если вдруг логика изменится),
        // RLS уже гарантирует это: "Users can view links in own folders".
    ])

    // Создаём Map для быстрого доступа
    const usersMap = new Map((usersResult.data || []).map(u => [u.id, u]))
    const requestsMap = new Map((requestsResult.data || []).map(r => [r.id, r]))
    const ordersMap = new Map((ordersResult.data || []).map(o => [o.id, o]))
    
    // Map для папок: conversation_id -> folder_id[]
    const folderLinksMap = new Map<string, string[]>()
    ;(folderLinksResult.data || []).forEach(link => {
      const existing = folderLinksMap.get(link.conversation_id) || []
      folderLinksMap.set(link.conversation_id, [...existing, link.folder_id])
    })
    
    // Считаем непрочитанные по conversation_id
    const unreadCountMap = new Map<string, number>()
    ;(unreadResult.data || []).forEach(msg => {
      const count = unreadCountMap.get(msg.conversation_id) || 0
      unreadCountMap.set(msg.conversation_id, count + 1)
    })

    // 3. Собираем результат без дополнительных запросов
    const enrichedConversations = conversations.map(conv => {
      const otherParticipantId = conv.participant_1_id === user.id 
        ? conv.participant_2_id 
        : conv.participant_1_id

        return {
          ...conv,
        other_participant: usersMap.get(otherParticipantId) || null,
        unread_count: unreadCountMap.get(conv.id) || 0,
        folder_ids: folderLinksMap.get(conv.id) || [],
        order_requests: conv.source_type === 'request' && conv.source_id 
          ? requestsMap.get(conv.source_id) || null 
          : null,
        order: conv.source_type === 'order' && conv.source_id 
          ? ordersMap.get(conv.source_id) || null 
          : null,
        }
      })

    return NextResponse.json({ conversations: enrichedConversations })
  } catch (error) {
    console.error('[API Conversations] Error:', error)
    return NextResponse.json({ error: 'Внутренняя ошибка сервера' }, { status: 500 })
  }
}

// POST /api/conversations — создать новый диалог
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient()

    const { data: { user }, error: authError } = await supabase.auth.getUser()
    if (authError || !user) {
      return NextResponse.json({ error: 'Необходимо авторизоваться' }, { status: 401 })
    }

    const body = await request.json()
    const { sourceType, sourceId, participantId, responseId, profileId } = body

    if (!sourceType || !sourceId || !participantId) {
      return NextResponse.json({ error: 'Недостаточно данных' }, { status: 400 })
    }

    // Создаём или получаем существующий чат
    const { data: conversationId, error } = await supabase.rpc('get_or_create_conversation', {
      p_source_type: sourceType,
      p_source_id: sourceId,
      p_participant_1: user.id,
      p_participant_2: participantId,
      p_response_id: responseId || null,
      p_profile_id: profileId || null,
    })

    if (error) {
      console.error('[API Conversations] Error creating:', error)
      return NextResponse.json({ error: 'Ошибка создания диалога' }, { status: 500 })
    }

    return NextResponse.json({ conversationId })
  } catch (error) {
    console.error('[API Conversations] Error:', error)
    return NextResponse.json({ error: 'Внутренняя ошибка сервера' }, { status: 500 })
  }
}

