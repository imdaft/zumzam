// TODO: MIGRATE QUERIES TO PRISMA
// –≠—Ç–æ—Ç —Ñ–∞–π–ª —á–∞—Å—Ç–∏—á–Ω–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç Supabase queries
// –û–Ω–∏ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –ø–æ–ª–Ω–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma

// TODO: MIGRATE TO PRISMA - —ç—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Supabase queries
// –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma –¥–ª—è consistency

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'

interface RouteParams {
  params: Promise<{ id: string }>
}

// PATCH /api/requests/responses/[id] ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ—Ç–∫–ª–∏–∫–∞
export async function PATCH(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: responseId } = await params
    // Supabase client removed
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub
    
    // Auth check done above,
        { status: 401 }
      )
    }

    const body = await request.json()
    const { status } = body

    // –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç–∞—Ç—É—Å–∞
    const validStatuses = ['viewed', 'accepted', 'rejected']
    if (!validStatuses.includes(status)) {
      return NextResponse.json(
        { error: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å—Ç–∞—Ç—É—Å' },
        { status: 400 }
      )
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–∫–ª–∏–∫ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –∑–∞—è–≤–∫–µ
    const { data: response, error: responseError } = await supabase
      .from('order_responses')
      .select(`
        *,
        order_requests (
          id,
          client_id,
          title
        )
      `)
      .eq('id', responseId)
      .single()

    if (responseError || !response) {
      return NextResponse.json(
        { error: '–û—Ç–∫–ª–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤–ª–∞–¥–µ–ª–µ—Ü –∑–∞—è–≤–∫–∏
    if (response.order_requests?.client_id !== userId) {
      return NextResponse.json(
        { error: '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –æ—Ç–∫–ª–∏–∫—É' },
        { status: 403 }
      )
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ç–∫–ª–∏–∫–∞
    const { data: updatedResponse, error: updateError } = await supabase
      .from('order_responses')
      .update({ 
        status,
        updated_at: new Date().toISOString()
      })
      .eq('id', responseId)
      .select()
      .single()

    // Error handling removed (Prisma throws exceptions),
        { status: 500 }
      )
    }

    // –ï—Å–ª–∏ –ø—Ä–∏–Ω—è—Ç ‚Äî –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–±—ä—è–≤–ª–µ–Ω–∏—è, —Å–æ–∑–¥–∞—ë–º —á–∞—Ç –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    if (status === 'accepted') {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–±—ä—è–≤–ª–µ–Ω–∏—è –Ω–∞ "–≤ —Ä–∞–±–æ—Ç–µ" ‚Äî –æ–Ω–æ –∏—Å—á–µ–∑–Ω–µ—Ç —Å –ø—É–±–ª–∏—á–Ω–æ–π –¥–æ—Å–∫–∏
      const { error: updateRequestError } = await supabase
        .from('order_requests')
        .update({ 
          status: 'in_progress',
          updated_at: new Date().toISOString()
        })
        .eq('id', response.request_id)
      
      if (updateRequestError) {
        logger.error('[API Response] Error updating request status:', updateRequestError)
      } else {
        logger.info('[API Response] Request status updated to in_progress:', response.request_id)
      }

      // –°–æ–∑–¥–∞—ë–º —á–∞—Ç –º–µ–∂–¥—É –∫–ª–∏–µ–Ω—Ç–æ–º –∏ –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª–µ–º
      const { data: conversationId } = await supabase.rpc('get_or_create_conversation', {
        p_source_type: 'request',
        p_source_id: response.request_id,
        p_participant_1: userId, // –∫–ª–∏–µ–Ω—Ç
        p_participant_2: response.performer_id, // –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—å
        p_response_id: responseId,
        p_profile_id: response.profile_id,
      })

      // –°–æ–∑–¥–∞—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è
      await supabase
        .from('notifications')
        .insert({
          user_id: response.performer_id,
          type: 'response_accepted',
          title: '–í–∞—à –æ—Ç–∫–ª–∏–∫ –ø—Ä–∏–Ω—è—Ç! üéâ',
          body: `–ó–∞–∫–∞–∑—á–∏–∫ –ø—Ä–∏–Ω—è–ª –≤–∞—à –æ—Ç–∫–ª–∏–∫ –Ω–∞ "${response.order_requests?.title}". –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ–±—â–∞—Ç—å—Å—è –≤ —á–∞—Ç–µ.`,
          action_url: conversationId ? `/messages?chat=${conversationId}` : `/board/${response.request_id}`,
          read: false,
          read_at: null,
          data: {
            request_id: response.request_id,
            response_id: responseId,
          },
        })
    }

    // –ï—Å–ª–∏ –æ—Ç–∫–ª–æ–Ω—ë–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è
    if (status === 'rejected') {
      await supabase
        .from('notifications')
        .insert({
          user_id: response.performer_id,
          type: 'response_rejected',
          title: '–û—Ç–∫–ª–∏–∫ –æ—Ç–∫–ª–æ–Ω—ë–Ω',
          body: `–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à –æ—Ç–∫–ª–∏–∫ –Ω–∞ "${response.order_requests?.title}" –Ω–µ –±—ã–ª –ø—Ä–∏–Ω—è—Ç`,
          action_url: `/board/${response.request_id}`,
          read: false,
          read_at: null,
          data: {
            request_id: response.request_id,
            response_id: responseId,
          },
        })
    }

    return NextResponse.json(updatedResponse)
  } catch (error) {
    logger.error('[API Response] Error:', error)
    return NextResponse.json(
      { error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    )
  }
}

// GET /api/requests/responses/[id] ‚Äî –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± –æ—Ç–∫–ª–∏–∫–µ
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id: responseId } = await params
    // Supabase client removed
    
    const { data: { user } } = await supabase.auth.getUser()
    
    if (!user) {
      return NextResponse.json(
        { error: '–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è' },
        { status: 401 }
      )
    }

    const { data: response, error } = await supabase
      .from('order_responses')
      .select(`
        *,
        profiles (
          id,
          slug,
          display_name,
          main_photo,
          rating,
          reviews_count
        ),
        order_requests (
          id,
          title,
          client_id
        )
      `)
      .eq('id', responseId)
      .single()

    if (error || !response) {
      return NextResponse.json(
        { error: '–û—Ç–∫–ª–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø: –≤–ª–∞–¥–µ–ª–µ—Ü –∑–∞—è–≤–∫–∏ –∏–ª–∏ –∞–≤—Ç–æ—Ä –æ—Ç–∫–ª–∏–∫–∞
    const isOwner = response.order_requests?.client_id === userId
    const isPerformer = response.performer_id === userId

    if (!isOwner && !isPerformer) {
      return NextResponse.json(
        { error: '–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –æ—Ç–∫–ª–∏–∫—É' },
        { status: 403 }
      )
    }

    return NextResponse.json(response)
  } catch (error) {
    logger.error('[API Response] Error:', error)
    return NextResponse.json(
      { error: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    )
  }
}

