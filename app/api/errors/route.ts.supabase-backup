import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { logger } from '@/lib/logger'

interface ErrorReport {
  message: string
  stack?: string
  source?: string
  lineno?: number
  colno?: number
  filename?: string
  url: string
  userAgent: string
  userId?: string
  userEmail?: string
  timestamp: string
  errorType: 'javascript' | 'unhandledrejection' | 'react' | 'other'
  componentStack?: string
  additionalData?: Record<string, any>
}

/**
 * API endpoint для приема ошибок с клиента
 * POST /api/errors
 */
export async function POST(request: NextRequest) {
  try {
    const errorData: ErrorReport = await request.json()

    // Валидация обязательных полей
    if (!errorData.message || !errorData.url) {
      return NextResponse.json(
        { error: 'Missing required fields: message, url' },
        { status: 400 }
      )
    }

    // Получаем информацию о пользователе из сессии
    const supabase = await createClient()
    const { data: { user } } = await supabase.auth.getUser()

    // Обогащаем данные ошибки информацией о пользователе
    const enrichedError: ErrorReport = {
      ...errorData,
      userId: user?.id,
      userEmail: user?.email,
      timestamp: errorData.timestamp || new Date().toISOString(),
    }

    // Логируем ошибку на сервере с полным контекстом
    logger.error('[Client Error]', {
      message: enrichedError.message,
      stack: enrichedError.stack,
      url: enrichedError.url,
      user: enrichedError.userId ? {
        id: enrichedError.userId,
        email: enrichedError.userEmail,
      } : 'anonymous',
      userAgent: enrichedError.userAgent,
      errorType: enrichedError.errorType,
      source: enrichedError.source,
      location: enrichedError.filename ? {
        file: enrichedError.filename,
        line: enrichedError.lineno,
        column: enrichedError.colno,
      } : undefined,
      componentStack: enrichedError.componentStack,
      additionalData: enrichedError.additionalData,
      timestamp: enrichedError.timestamp,
    })

    // Сохраняем ошибку в БД
    try {
      // Проверяем частоту этой ошибки за последний час для автоопределения критичности
      const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString()
      const { data: recentErrors } = await supabase
        .from('errors')
        .select('id')
        .eq('message', enrichedError.message)
        .gte('created_at', oneHourAgo)

      const errorFrequency = (recentErrors?.length || 0) + 1
      
      // Автоматическое определение критичности:
      // - React/Global ошибки всегда критичные
      // - Более 10 повторений за час = критическая
      // - Более 5 повторений за час = потенциально критическая
      const isAutoCritical = 
        enrichedError.errorType === 'react' || 
        enrichedError.additionalData?.isGlobalError === true ||
        errorFrequency > 10

      const { error: dbError } = await supabase
        .from('errors')
        .insert({
          message: enrichedError.message,
          stack: enrichedError.stack,
          source: enrichedError.source,
          lineno: enrichedError.lineno,
          colno: enrichedError.colno,
          filename: enrichedError.filename,
          url: enrichedError.url,
          user_agent: enrichedError.userAgent,
          user_id: enrichedError.userId,
          user_email: enrichedError.userEmail,
          error_type: enrichedError.errorType,
          component_stack: enrichedError.componentStack,
          additional_data: {
            ...enrichedError.additionalData,
            frequency: errorFrequency,
          },
          is_critical: isAutoCritical,
        })

      if (dbError) {
        logger.error('[Error Handler] Failed to save error to DB', dbError)
      } else if (isAutoCritical && errorFrequency === 1) {
        // Отправляем email уведомление только при первом появлении критической ошибки
        try {
          await fetch(`${process.env.NEXT_PUBLIC_SITE_URL || ''}/api/admin/errors/notify`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              error: enrichedError,
              frequency: errorFrequency,
            }),
          }).catch(() => {
            // Игнорируем ошибки отправки уведомлений
          })
        } catch (notifyErr) {
          logger.error('[Error Handler] Failed to send notification', notifyErr)
        }
      }
    } catch (dbErr) {
      logger.error('[Error Handler] Exception while saving error to DB', dbErr)
    }

    return NextResponse.json(
      { success: true, received: true },
      { status: 200 }
    )
  } catch (error) {
    // Ошибка при обработке ошибки (мета-ошибка)
    logger.error('[Error Handler] Failed to process error report', error)
    
    return NextResponse.json(
      { error: 'Failed to process error report' },
      { status: 500 }
    )
  }
}
















