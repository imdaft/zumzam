// TODO: MIGRATE QUERIES TO PRISMA
// –≠—Ç–æ—Ç —Ñ–∞–π–ª —á–∞—Å—Ç–∏—á–Ω–æ –º–∏–≥—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ —Å–æ–¥–µ—Ä–∂–∏—Ç Supabase queries
// –û–Ω–∏ –±—É–¥—É—Ç —Ä–∞–±–æ—Ç–∞—Ç—å, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –ø–æ–ª–Ω–æ–π –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma

// TODO: MIGRATE TO PRISMA - —ç—Ç–æ—Ç —Ñ–∞–π–ª –∏—Å–ø–æ–ª—å–∑—É–µ—Ç Supabase queries
// –û–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ —Ç—Ä–µ–±—É—é—Ç –º–∏–≥—Ä–∞—Ü–∏–∏ –Ω–∞ Prisma –¥–ª—è consistency

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/lib/prisma'
import { verifyToken } from '@/lib/auth/jwt'

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await params
    const campaignId = resolvedParams.id
    
    logger.info('[Analytics API] üîç Request for campaign:', campaignId)
    
    // Supabase client removed
    const token = request.cookies.get('auth-token')?.value
    if (!token) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const payload = await verifyToken(token)
    if (!payload) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    const userId = payload.sub

    // Auth check done above, { status: 401 })
    }

    logger.info('[Analytics API] ‚úÖ User authenticated:', userId)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { data: userData } = await supabase
      .from('users')
      .select('role')
      .eq('id', userId)
      .single()

    const isAdmin = userData?.role === 'admin'
    logger.info('[Analytics API] üë§ User role:', userData?.role)

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∫–∞–º–ø–∞–Ω–∏—è –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    logger.info('[Analytics API] üîé Fetching campaign:', campaignId)
    
    // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∫–∞–º–ø–∞–Ω–∏–∏
    const { data: campaign, error: campaignError } = await supabase
      .from('ad_campaigns')
      .select('id, title, user_id, profile_id, stats')
      .eq('id', campaignId)
      .single()

    if (campaignError || !campaign) {
      logger.error('[Analytics API] ‚ùå Campaign not found:', campaignError)
      return NextResponse.json(
        { error: 'Campaign not found', details: campaignError?.message },
        { status: 404 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ (–∞–¥–º–∏–Ω—ã –∏–º–µ—é—Ç –¥–æ—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞–º–ø–∞–Ω–∏—è–º)
    if (!isAdmin && campaign.user_id !== userId) {
      logger.error('[Analytics API] ‚ùå Access denied: campaign.user_id !== userId')
      return NextResponse.json({ error: 'Access denied' }, { status: 403 })
    }

    logger.info('[Analytics API] ‚úÖ Campaign found:', campaign.title)

    // –°–æ–±–∏—Ä–∞–µ–º –∞–Ω–∞–ª–∏—Ç–∏–∫—É
    logger.info('[Analytics API] üìä Fetching impressions...')
    const { data: impressions, error: impressionsError } = await supabase
      .from('ad_impressions')
      .select('*')
      .eq('campaign_id', campaignId)

    if (impressionsError) {
      logger.error('[Analytics API] ‚ùå Impressions error:', impressionsError)
      throw impressionsError
    }

    logger.info('[Analytics API] ‚úÖ Found impressions:', impressions?.length || 0)

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º
    const deviceStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      const device = imp.device_type || 'unknown'
      deviceStats[device] = (deviceStats[device] || 0) + 1
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –±—Ä–∞—É–∑–µ—Ä–∞–º
    const browserStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      const browser = imp.browser || 'unknown'
      browserStats[browser] = (browserStats[browser] || 0) + 1
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –û–°
    const osStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      const os = imp.os || 'unknown'
      osStats[os] = (osStats[os] || 0) + 1
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –≥–æ—Ä–æ–¥–∞–º
    const cityStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      if (imp.city) {
        cityStats[imp.city] = (cityStats[imp.city] || 0) + 1
      }
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å—Ç—Ä–∞–Ω–∞–º
    const countryStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      if (imp.country) {
        countryStats[imp.country] = (countryStats[imp.country] || 0) + 1
      }
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ referrer
    const referrerStats: Record<string, number> = {}
    impressions?.forEach(imp => {
      if (imp.referrer) {
        referrerStats[imp.referrer] = (referrerStats[imp.referrer] || 0) + 1
      }
    })

    // –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
    const validTimes = impressions?.filter(imp => imp.time_on_page).map(imp => imp.time_on_page) || []
    const avgTimeOnPage = validTimes.length > 0
      ? Math.round(validTimes.reduce((sum, time) => sum + time, 0) / validTimes.length)
      : 0

    // Timeline –ø–æ –¥–Ω—è–º
    const timeline: Record<string, { impressions: number; clicks: number }> = {}
    impressions?.forEach(imp => {
      const date = new Date(imp.created_at).toISOString().split('T')[0]
      if (!timeline[date]) {
        timeline[date] = { impressions: 0, clicks: 0 }
      }
      if (imp.action === 'impression') {
        timeline[date].impressions++
      } else if (imp.action === 'click') {
        timeline[date].clicks++
      }
    })

    return NextResponse.json({
      campaign: {
        id: campaign.id,
        title: campaign.title,
        stats: campaign.stats || { impressions: 0, clicks: 0, spent: 0 }
      },
      demographics: {
        devices: Object.entries(deviceStats)
          .map(([device_type, count]) => ({ device_type, count }))
          .sort((a, b) => b.count - a.count),
        browsers: Object.entries(browserStats)
          .map(([browser, count]) => ({ browser, count }))
          .sort((a, b) => b.count - a.count),
        os: Object.entries(osStats)
          .map(([os, count]) => ({ os, count }))
          .sort((a, b) => b.count - a.count),
        cities: Object.entries(cityStats)
          .map(([city, count]) => ({ city, count }))
          .sort((a, b) => b.count - a.count),
        countries: Object.entries(countryStats)
          .map(([country, count]) => ({ country, count }))
          .sort((a, b) => b.count - a.count)
      },
      timeline: Object.entries(timeline)
        .map(([date, stats]) => ({ date, ...stats }))
        .sort((a, b) => a.date.localeCompare(b.date)),
      topReferrers: Object.entries(referrerStats)
        .map(([referrer, count]) => ({ referrer, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10),
      avgTimeOnPage,
      bounceRate: 0 // TODO: calculate bounce rate
    })
  } catch (error: any) {
    logger.error('[Campaign Analytics API] Error:', error)
    return NextResponse.json(
      { error: 'Internal error', details: error?.message },
      { status: 500 }
    )
  }
}

